<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Shared Memory · Inter-Process Communication</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Inter-Process Communication logo"/></a><h1>Inter-Process Communication</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">A Julia Package for Inter-Process Communication</a></li><li><a class="toctext" href="../semaphores/">Semaphores</a></li><li class="current"><a class="toctext" href>Shared Memory</a><ul class="internal"><li><a class="toctext" href="#Shared-Memory-Objects-1">Shared Memory Objects</a></li><li><a class="toctext" href="#BSD-System-V-Shared-Memory-1">BSD System V Shared Memory</a></li></ul></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Shared Memory</a></li></ul><a class="edit-page" href="https://github.com/emmt/IPC.jl/blob/master/docs/src/sharedmemory.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Shared Memory</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Shared-Memory-1" href="#Shared-Memory-1">Shared Memory</a></h1><p>The <code>IPC</code> package provides two kinds of shared memory objects: <em>named shared memory</em> objects which are identified by their name and <em>BSD (System V) shared memory segments</em> which are identified by a key.</p><h2><a class="nav-anchor" id="Shared-Memory-Objects-1" href="#Shared-Memory-Objects-1">Shared Memory Objects</a></h2><p>Shared memory objects are instances of <code>IPC.SharedMemory</code>.  A new shared memory object is created by calling:</p><pre><code class="language-julia">SharedMemory(id, len; perms=0o600, volatile=true)</code></pre><p>with <code>id</code> an identifier and <code>len</code> the size, in bytes, of the allocated memory. The identifier <code>id</code> can be a string starting by a <code>&#39;/&#39;</code> to create a POSIX shared memory object or a System V IPC key to create a BSD System V shared memory segment.  In this latter case, the key can be <code>IPC.PRIVATE</code> to automatically create a non-existing shared memory segment.</p><p>Use keyword <code>perms</code> to specify which access permissions are granted.  By default, only reading and writing by the user is granted.</p><p>Use keyword <code>volatile</code> to specify whether the shared memory is volatile or not. If non-volatile, the shared memory will remain accessible until explicit destruction or system reboot.  By default, the shared memory is destroyed when no longer in use.</p><p>To retrieve an existing shared memory object, call:</p><pre><code class="language-julia">SharedMemory(id; readonly=false)</code></pre><p>where <code>id</code> is the shared memory identifier (a string, an IPC key or a System V IPC identifier of shared memory segment as returned by <code>ShmId</code>).  Keyword <code>readonly</code> can be set true if only read access is needed.  Note that method <code>shmid(obj)</code> may be called to retrieve the identifier of the shared memory object <code>obj</code>.</p><p>Some methods are extended for shared memory objects.  Assuming <code>shm</code> is an instance of <code>SharedMemory</code>, then:</p><pre><code class="language-julia">pointer(shm)    # yields the base address of the shared memory
sizeof(shm)     # yields the number of bytes of the shared memory
shmid(shm)      # yields the identifier the shared memory</code></pre><p>To ensure that shared memory object <code>shm</code> is eventually destroyed, call:</p><pre><code class="language-julia">rm(shm)</code></pre><h2><a class="nav-anchor" id="BSD-System-V-Shared-Memory-1" href="#BSD-System-V-Shared-Memory-1">BSD System V Shared Memory</a></h2><p>The following methods and type give a lower-level access (compared to <code>SharedMemory</code> objects) to manage BSD System V shared memory segments.</p><h3><a class="nav-anchor" id="System-V-shared-memory-segment-identifiers-1" href="#System-V-shared-memory-segment-identifiers-1">System V shared memory segment identifiers</a></h3><p>The following statements:</p><pre><code class="language-julia">ShmId(id)                  -&gt; id
ShmId(arr)                 -&gt; id
ShmId(key, readlony=false) -&gt; id</code></pre><p>yield the the identifier of the existing System V shared memory segment associated with the value of the first argument.  <code>id</code> is the identifier of the shared memory segment, <code>arr</code> is an array attached to a System V shared memory segment and <code>key</code> is the key associated with the shared memory segment.  In that latter case, <code>readlony</code> can be set <code>true</code> to only request read-only access; otherwise read-write access is requested.</p><h3><a class="nav-anchor" id="Getting-or-creating-a-shared-memory-segment-1" href="#Getting-or-creating-a-shared-memory-segment-1">Getting or creating a shared memory segment</a></h3><p>Call:</p><pre><code class="language-julia">shmget(key, siz, flg) -&gt; id</code></pre><p>to get the identifier of the shared memory segment associated with the System V IPC key <code>key</code>.  A new shared memory segment, with size equal to the value of <code>siz</code> (possibly rounded up to a multiple of the memory page size <code>IPC.PAGE_SIZE</code>), is created if <code>key</code> has the value <code>IPC.PRIVATE</code> or if <code>IPC_CREAT</code> is specified in the argument <code>flg</code>, <code>key</code> isn&#39;t <code>IPC.PRIVATE</code> and no shared memory segment corresponding to <code>key</code> exists.</p><p>Argument <code>flg</code> is a bitwise combination of flags.  The least significant 9 bits specify the permissions granted to the owner, group, and others.  These bits have the same format, and the same meaning, as the mode argument of <code>chmod</code>. Bit <code>IPC_CREAT</code> can be set to create a new segment.  If this flag is not used, then <code>shmget</code> will find the segment associated with <code>key</code> and check to see if the user has permission to access the segment.  Bit <code>IPC_EXCL</code> can be set in addition to <code>IPC_CREAT</code> to ensure that this call creates the segment.  If <code>IPC_EXCL</code> and <code>IPC_CREAT</code> are both set, the call will fail if the segment already exists.</p><h3><a class="nav-anchor" id="Attaching-and-detaching-shared-memory-1" href="#Attaching-and-detaching-shared-memory-1">Attaching and detaching shared memory</a></h3><p>Call:</p><pre><code class="language-julia">shmat(id, readonly) -&gt; ptr</code></pre><p>to attach an existing shared memory segment to the address space of the caller. Argument <code>id</code> is the identifier of the shared memory segment.  Boolean argument <code>readonly</code> specifies whether to attach the segment for read-only access; otherwise, the segment is attached for read and write accesses and the process must have read and write permissions for the segment.  The returned value is a pointer to the shared memory segment in the caller address space.</p><p>Assuming <code>ptr</code> is the pointer returned by a previous <code>shmat()</code> call:</p><pre><code class="language-julia">shmdt(ptr)</code></pre><p>detaches the System V shared memory segment from the address space of the caller.</p><h3><a class="nav-anchor" id="Destroying-shared-memory-1" href="#Destroying-shared-memory-1">Destroying shared memory</a></h3><p>To remove shared memory assoicaite with <code>arg</code>, call:</p><pre><code class="language-julia">shmrm(arg)</code></pre><p>If <code>arg</code> is a name, the corresponding POSIX named shared memory is unlinked. If <code>arg</code> is a key or identifier of a BSD shared memory segment, the segment is marked to be eventually destroyed.  Argument <code>arg</code> can also be a <code>SharedMemory</code> object.</p><p>The <code>rm</code> method may also be called to remove an existing shared memory segment or object:</p><pre><code class="language-julia">rm(SharedMemory, name)
rm(SharedMemory, key)
rm(id)
rm(shm)</code></pre><p>where <code>name</code> identifies a POSIX shared memory object, <code>key</code> is associated with a BSD shared memory segment, <code>id</code> is the identifier of a BSD shared memory segment and <code>shm</code> is an instance of <code>SharedMemory</code>.</p><h3><a class="nav-anchor" id="Controlling-shared-memory-1" href="#Controlling-shared-memory-1">Controlling shared memory</a></h3><p>To change the access permissions of a System V IPC shared memory segment, call:</p><pre><code class="language-julia">shmcfg(arg, perms) -&gt; id</code></pre><p>where <code>perms</code> specifies bitwise flags with the new permissions.  The first argument can be the identifier of the shared memory segment, a shared array attached to the shared memory segment or the System V IPC key associated with the shared memory segment.  In all cases, the identifier of the shared memory segment is returned.</p><p>Other control operations can be performed with:</p><pre><code class="language-julia">shmctl(id, cmd, buf)</code></pre><p>where <code>id</code> is the identifier of the shared memory segment, <code>cmd</code> is the command to perform and <code>buf</code> is a buffer large enough to store a <code>shmid_ds</code> C structure (<code>IPC._sizeof_struct_shmid_ds</code> bytes).</p><h3><a class="nav-anchor" id="Retrieving-shared-memory-information-1" href="#Retrieving-shared-memory-information-1">Retrieving shared memory information</a></h3><p>To retrieve information about a System V shared memory segment, call one of:</p><pre><code class="language-julia">shminfo(arg) -&gt; info
ShmInfo(arg) -&gt; info</code></pre><p>with <code>arg</code> the identifier of the shared memory segment, a shared array attached to the shared memory segment or the System V IPC key associated with the shared memory segment.  The result is an instance of  <code>ShmInfo</code>.</p><p>Memory for the <code>ShmInfo</code> structure may be provided:</p><pre><code class="language-julia">shminfo!(arg, info) -&gt; info</code></pre><p>where <code>info</code> is an instance of <code>ShmInfo</code> which is overwritten with information about <code>arg</code> and returned.</p><footer><hr/><a class="previous" href="../semaphores/"><span class="direction">Previous</span><span class="title">Semaphores</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
