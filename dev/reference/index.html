<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Inter-Process Communication</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Inter-Process Communication logo"/></a><h1>Inter-Process Communication</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">A Julia Package for Inter-Process Communication</a></li><li><a class="toctext" href="../semaphores/">Semaphores</a></li><li><a class="toctext" href="../sharedmemory/">Shared Memory</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Semaphores-1">Semaphores</a></li><li><a class="toctext" href="#Shared-Memory-1">Shared Memory</a></li><li><a class="toctext" href="#Signals-1">Signals</a></li><li><a class="toctext" href="#Wrapped-arrays-1">Wrapped arrays</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li><a class="toctext" href="#Exceptions-1">Exceptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/emmt/IPC.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><p>The following provides detailled documentation about types and methods provided by the IPC package.  This information is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2><a class="nav-anchor" id="Semaphores-1" href="#Semaphores-1">Semaphores</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.Semaphore" href="#IPC.Semaphore"><code>IPC.Semaphore</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Named Semaphores</strong></p><pre><code class="language-julia">Semaphore(name, value; perms=0o600, volatile=true) -&gt; sem</code></pre><p>creates a new named semaphore identified by the string <code>name</code> of the form <code>&quot;/somename&quot;</code> and initial value set to <code>value</code>.  An instance of <code>Semaphore{String}</code> is returned.  Keyword <code>perms</code> can be used to specify access permissions.  Keyword <code>volatile</code> specify whether the semaphore should be unlinked when the returned object is finalized.</p><pre><code class="language-julia">Semaphore(name) -&gt; sem</code></pre><p>opens an existing named semaphore and returns an instance of <code>Semaphore{String}</code>.</p><p>To unlink (remove) a persistent named semaphore, simply do:</p><pre><code class="language-julia">rm(Semaphore, name)</code></pre><p>If the semaphore does not exists, the error is ignored.  A <code>SystemError</code> is however thrown for other errors.</p><p>For maximum flexibility, an instance of a named semaphore may also be created by:</p><pre><code class="language-julia">open(Semaphore, name, flags, mode, value, volatile) -&gt; sem</code></pre><p>where <code>flags</code> may have the bits <code>IPC.O_CREAT</code> and <code>IPC.O_EXCL</code> set, <code>mode</code> specifies the granted access permissions, <code>value</code> is the initial semaphore value and <code>volatile</code> is a boolean indicating whether the semaphore should be unlinked when the returned object <code>sem</code> is finalized.  The values of <code>mode</code> and <code>value</code> are ignored if an existing named semaphore is open.</p><p><strong>Anonymous Semaphores</strong></p><p>Anonymous semaphores are backed by <em>memory</em> objects providing the necessary storage.</p><pre><code class="language-julia">Semaphore(mem, value; offset=0, volatile=true) -&gt; sem</code></pre><p>initializes an anonymous semaphore backed by memory object <code>mem</code> with initial value set to <code>value</code> and returns an instance of <code>Semaphore{typeof(mem)}</code>. Keyword <code>offset</code> can be used to specify the address (in bytes) of the semaphore data relative to <code>pointer(mem)</code>.  Keyword <code>volatile</code> specify whether the semaphore should be destroyed when the returned object is finalized.</p><pre><code class="language-julia">Semaphore(mem; offset=0) -&gt; sem</code></pre><p>yields an an instance of <code>Semaphore{typeof(mem)}</code> associated with an initialized anonymous semaphore and backed by memory object <code>mem</code> at relative position (in bytes) specified by keyword <code>offset</code>.</p><p>The number of bytes needed to store an anonymous semaphore is given by <code>sizeof(Semaphore)</code> and anonymous semaphore must be aligned in memory at multiples of the word size (that is <code>Sys.WORD_SIZE &gt;&gt; 3</code> in bytes).  Memory objects used to store an anonymous semaphore must implement two methods: <code>pointer(mem)</code> and <code>sizeof(mem)</code> to yield respectively the base address and the size (in bytes) of the associated memory.</p><p>See also: <a href="#IPC.post-Tuple{Semaphore}"><code>post</code></a>, <a href="#Base.wait-Tuple{Semaphore}"><code>wait</code></a>, <a href="#Base.timedwait-Tuple{Semaphore,Real}"><code>timedwait</code></a>,           <a href="#IPC.trywait-Tuple{Semaphore}"><code>trywait</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/semaphores.jl#L12-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.post-Tuple{Semaphore}" href="#IPC.post-Tuple{Semaphore}"><code>IPC.post</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">post(sem)</code></pre><p>increments (unlocks) the semaphore <code>sem</code>.  If the semaphore&#39;s value consequently becomes greater than zero, then another process or thread blocked in a <a href="#Base.wait-Tuple{Semaphore}"><code>wait</code></a> call on this semaphore will be woken up.</p><p>See also: <a href="#IPC.Semaphore"><code>Semaphore</code></a>, <a href="#Base.wait-Tuple{Semaphore}"><code>wait</code></a>, <a href="#Base.timedwait-Tuple{Semaphore,Real}"><code>timedwait</code></a>,           <a href="#IPC.trywait-Tuple{Semaphore}"><code>trywait</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/semaphores.jl#L196-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.wait-Tuple{Semaphore}" href="#Base.wait-Tuple{Semaphore}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">wait(sem)</code></pre><p>decrements (locks) the semaphore <code>sem</code>.  If the semaphore&#39;s value is greater than zero, then the decrement proceeds and the function returns immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call (in which case an instance of <code>InterruptException</code> is thrown).  A <code>SystemError</code> may be thrown if an unexpected error occurs.</p><p>See also: <a href="#IPC.Semaphore"><code>Semaphore</code></a>, <a href="#IPC.post-Tuple{Semaphore}"><code>post</code></a>, <a href="#Base.timedwait-Tuple{Semaphore,Real}"><code>timedwait</code></a>,           <a href="#IPC.trywait-Tuple{Semaphore}"><code>trywait</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/semaphores.jl#L212-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.timedwait-Tuple{Semaphore,Real}" href="#Base.timedwait-Tuple{Semaphore,Real}"><code>Base.timedwait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">timedwait(sem, secs)</code></pre><p>decrements (locks) the semaphore <code>sem</code>.  If the semaphore&#39;s value is greater than zero, then the decrement proceeds and the function returns immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or the limit of <code>secs</code> seconds expires (in which case an instance of <a href="#IPC.TimeoutError"><code>TimeoutError</code></a> is thrown), or a signal handler interrupts the call (in which case an instance of <code>InterruptException</code> is thrown).</p><p>See also: <a href="#IPC.Semaphore"><code>Semaphore</code></a>, <a href="#IPC.post-Tuple{Semaphore}"><code>post</code></a>, <a href="#Base.wait-Tuple{Semaphore}"><code>wait</code></a>,           <a href="#IPC.trywait-Tuple{Semaphore}"><code>trywait</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/semaphores.jl#L241-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.trywait-Tuple{Semaphore}" href="#IPC.trywait-Tuple{Semaphore}"><code>IPC.trywait</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">trywait(sem) -&gt; boolean</code></pre><p>attempts to immediately decrement (lock) the semaphore <code>sem</code> returning <code>true</code> if successful.  If the decrement cannot be immediately performed, then the call returns <code>false</code>.  If an interruption is received or if an unexpected error occurs, an exception is thrown (<code>InterruptException</code> or <code>SystemError</code> repectively).</p><p>See also: <a href="#IPC.Semaphore"><code>Semaphore</code></a>, <a href="#IPC.post-Tuple{Semaphore}"><code>post</code></a>, <a href="#Base.wait-Tuple{Semaphore}"><code>wait</code></a>,           <a href="#Base.timedwait-Tuple{Semaphore,Real}"><code>timedwait</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/semaphores.jl#L276-L290">source</a></section><h2><a class="nav-anchor" id="Shared-Memory-1" href="#Shared-Memory-1">Shared Memory</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.SharedMemory" href="#IPC.SharedMemory"><code>IPC.SharedMemory</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SharedMemory(id, len; perms=0o600, volatile=true)</code></pre><p>yields a new shared memory object identified by <code>id</code> and whose size is <code>len</code> bytes.  The identifier <code>id</code> can be a string starting by a <code>&#39;/&#39;</code> to create a POSIX shared memory object or a System V IPC key to create a System V shared memory segment.  In this latter case, the key can be <code>IPC.PRIVATE</code> to automatically create a non-existing shared memory segment.</p><p>Keyword <code>perms</code> can be used to specify which access permissions are granted. By default, only reading and writing by the user is granted.</p><p>Keyword <code>volatile</code> can be used to specify whether the shared memory is volatile or not.  If non-volatile, the shared memory will remain accessible until explicit destruction or system reboot.  By default, the shared memory is destroyed when no longer in use.</p><p>To retrieve an existing shared memory object, call:</p><pre><code class="language-julia">SharedMemory(id; readonly=false)</code></pre><p>where <code>id</code> is the shared memory identifier (a string, an IPC key or a System V IPC identifier of shared memory segment as returned by <code>ShmId</code>).  Keyword <code>readonly</code> can be set true if only read access is needed.  Note that method <code>shmid(obj)</code> may be called to retrieve the identifier of the shared memory object <code>obj</code>.</p><p>Some methods are extended for shared memory objects.  Assuming <code>shm</code> is an instance of <code>SharedMemory</code>, then:</p><pre><code class="language-julia">pointer(shm)    # yields the base address of the shared memory
sizeof(shm)     # yields the number of bytes of the shared memory
shmid(shm)      # yields the identifier the shared memory</code></pre><p>To ensure that shared memory object <code>shm</code> is eventually destroyed, call:</p><pre><code class="language-julia">rm(shm)</code></pre><p>See also <a href="#IPC.shmid"><code>shmid</code></a>, <a href="#IPC.shmrm"><code>shmrm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L13-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.ShmId" href="#IPC.ShmId"><code>IPC.ShmId</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Get the identifier of an existing System V shared memory segment</strong></p><p>The following calls:</p><pre><code class="language-julia">ShmId(id)                  -&gt; id
ShmId(arr)                 -&gt; id
ShmId(key, readlony=false) -&gt; id</code></pre><p>yield the the identifier of the existing System V shared memory segment associated with the value of the first argument.  <code>id</code> is the identifier of the shared memory segment, <code>arr</code> is an array attached to a System V shared memory segment and <code>key</code> is the key associated with the shared memory segment.  In that latter case, <code>readlony</code> can be set <code>true</code> to only request read-only access; otherwise read-write access is requested.</p><p>See also: <a href="#IPC.shmid"><code>shmid</code></a>, <a href="#IPC.shmget"><code>shmget</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L340-L360">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.ShmInfo" href="#IPC.ShmInfo"><code>IPC.ShmInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>ShmInfo</code> is the structure used to store information about a System V shared memory segment. The call <code>ShmInfo(arg)</code> is equivalent to <a href="#IPC.shminfo"><code>shminfo(arg)</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L511-L516">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmid" href="#IPC.shmid"><code>IPC.shmid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shmid(arg)</code></pre><p>yield the identifier of an existing POSIX shared memory object or Sytem V shared memory segment identifed by <code>arg</code> or associated with <code>arg</code>.  Argument can be:</p><ul><li><p>An instance of <code>SharedMemory</code>.</p></li><li><p>An instance of <code>WrappedArray</code> whose contents is stored into shared memory.</p></li><li><p>A string starting with a <code>&#39;/&#39;</code> (and no other <code>&#39;/&#39;</code>) to identify a POSIX shared memory object.</p></li><li><p>An instance of <code>IPC.Key</code> to specify a System V IPC key associated with a shared memory segment.  In that case, an optional second argument <code>readonly</code> can be set <code>true</code> to only request read-only access; otherwise read-write access is requested.</p></li><li><p>An instance of <code>ShmId</code> to specify a System V shared memory segment.</p></li></ul><p>See also: <a href="#IPC.SharedMemory"><code>SharedMemory</code></a>, <a href="#IPC.shmrm"><code>shmrm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L227-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmget" href="#IPC.shmget"><code>IPC.shmget</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><strong>Get or create a System V shared memory segment</strong></p><p>The call:</p><pre><code class="language-julia">shmget(key, siz, flg) -&gt; id</code></pre><p>yields the identifier of the shared memory segment associated with the value of the argument <code>key</code>.  A new shared memory segment, with size equal to the value of <code>siz</code> (possibly rounded up to a multiple of the memory page size <code>IPC.PAGE_SIZE</code>), is created if <code>key</code> has the value <code>IPC.PRIVATE</code> or <code>key</code> isn&#39;t <code>IPC.PRIVATE</code>, no shared memory segment corresponding to <code>key</code> exists, and <code>IPC_CREAT</code> is specified in argument <code>flg</code>.</p><p>Arguments are:</p><ul><li><p><code>key</code> is the System V IPC key associated with the shared memory segment.</p></li><li><p><code>siz</code> specifies the size (in bytes) of the shared memory segment (may be rounded up to multiple of the memory page size).</p></li><li><p><code>flg</code> is a bitwise combination of flags.  The least significant 9 bits specify the permissions granted to the owner, group, and others.  These bits have the same format, and the same meaning, as the mode argument of <code>chmod</code>. Bit <code>IPC_CREAT</code> can be set to create a new segment.  If this flag is not used, then <code>shmget</code> will find the segment associated with <code>key</code> and check to see if the user has permission to access the segment.  Bit <code>IPC_EXCL</code> can be set in addition to <code>IPC_CREAT</code> to ensure that this call creates the segment. If <code>IPC_EXCL</code> and <code>IPC_CREAT</code> are both set, the call will fail if the segment already exists.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L367-L400">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmat" href="#IPC.shmat"><code>IPC.shmat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shmat(id, readonly) -&gt; ptr</code></pre><p>attaches a shared memory segment to the address space of the caller.  Argument <code>id</code> is the identifier of the shared memory segment.  Boolean argument <code>readonly</code> specifies whether to attach the segment for read-only access; otherwise, the segment is attached for read and write accesses and the process must have read and write permissions for the segment.  The returned value is the pointer to access the shared memory segment.</p><p>See also: <a href="#IPC.shmdt"><code>shmdt</code></a>, <a href="#IPC.shmrm"><code>shmrm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L411-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmdt" href="#IPC.shmdt"><code>IPC.shmdt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shmdt(ptr)</code></pre><p>detaches a System V shared memory segment from the address space of the caller. Argument <code>ptr</code> is the pointer returned by a previous <code>shmat()</code> call.</p><p>See also: <a href="#IPC.shmdt"><code>shmdt</code></a>, <a href="#IPC.shmget"><code>shmget</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L437-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmrm" href="#IPC.shmrm"><code>IPC.shmrm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shmrm(arg)</code></pre><p>removes the shared memory associated with <code>arg</code>.  If <code>arg</code> is a name, the corresponding POSIX named shared memory is unlinked.  If <code>arg</code> is a key or identifier of a BSD shared memory segment, the segment is marked to be eventually destroyed.  Argument <code>arg</code> can also be a <code>SharedMemory</code> object.</p><p>The <code>rm</code> method may also be called to remove an existing shared memory segment or object.  There are several possibilities:</p><pre><code class="language-julia">rm(SharedMemory, name)  # `name` identifies a POSIX shared memory object
rm(SharedMemory, key)   # `key` is associated with a BSD shared memory segment
rm(id)                  # `id` is the identifier of a BSD shared memory segment
rm(shm)                 # `shm` is an instance of `SharedMemory`</code></pre><p>See also: <a href="#IPC.SharedMemory"><code>SharedMemory</code></a>, <a href="#IPC.shmid"><code>shmid</code></a>, <a href="#IPC.shmat"><code>shmat</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L263-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmctl" href="#IPC.shmctl"><code>IPC.shmctl</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shmctl(id, cmd, buf)</code></pre><p>performs the control operation specified by <code>cmd</code> on the System V shared memory segment whose identifier is given in <code>id</code>.  The <code>buf</code> argument is a pointer to a <code>shmid_ds</code> C structure.</p><p>See also <a href="#IPC.shminfo"><code>shminfo</code></a>, <a href="#IPC.shmcfg"><code>shmcfg</code></a> and <a href="#IPC.shmrm"><code>shmrm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L453-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shmcfg" href="#IPC.shmcfg"><code>IPC.shmcfg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shmcfg(arg, perms) -&gt; id</code></pre><p>changes the access permissions of a System V IPC shared memory segment. Argument <code>perms</code> specifies bitwise flags with the new permissions.  The first argument <code>arg</code> can be the identifier of the shared memory segment, a shared array attached to the shared memory segment or the System V IPC key associated with the shared memory segment.  In all cases, the identifier of the shared memory segment is returned.</p><p>See also <a href="#IPC.ShmId"><code>ShmId</code></a>, <a href="#IPC.shmget"><code>shmget</code></a>, <a href="#IPC.shmctl"><code>shmctl</code></a> and <a href="#IPC.SharedMemory"><code>SharedMemory</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L474-L490">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shminfo" href="#IPC.shminfo"><code>IPC.shminfo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shminfo(arg) -&gt; info</code></pre><p>yields information about the System V shared memory segment identified or associated with <code>arg</code> which can be the identifier of the shared memory segment, a shared array attached to the shared memory segment or the System V IPC key associated with the shared memory segment.</p><p>See also <a href="#IPC.ShmInfo"><code>ShmInfo</code></a>, <a href="#IPC.ShmId"><code>ShmId</code></a>, <a href="#IPC.shmget"><code>shmget</code></a>, <a href="#IPC.shmat"><code>shmat</code></a>, <a href="#IPC.SharedMemory"><code>SharedMemory</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L519-L533">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.shminfo!" href="#IPC.shminfo!"><code>IPC.shminfo!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shminfo!(arg, info) -&gt; info</code></pre><p>overwrites <code>info</code> (an instance of <a href="#IPC.ShmInfo"><code>ShmInfo</code></a>) with the information about the System V shared memory segment identified or associated with <code>arg</code>.  See <a href="#IPC.shminfo"><code>shminfo</code></a> for more details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/shm.jl#L536-L546">source</a></section><h2><a class="nav-anchor" id="Signals-1" href="#Signals-1">Signals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.SigSet" href="#IPC.SigSet"><code>IPC.SigSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SigSet</code> represents a C <code>sigset_t</code> structure.  It should be considered as <em>opaque</em>, its contents is stored as a tuple of unsigned integers whose size matches that of <code>sigset_t</code>.</p><p>Typical usage is:</p><pre><code class="language-julia">sigset = SigSet()
sigset[signum] -&gt; boolean
sigset[signum] = boolean
fill!(sigset, boolean) -&gt; sigset</code></pre><pre><code class="language-julia">IPC.sigfillset!(sigset)          # same as fill!(signum, true)
IPC.sigemptyset!(sigset)         # same as fill!(signum, false)
IPC.sigaddset!(sigset, signum)   # same as sigset[signum] = true
IPC.sigdelset!(sigset, signum)   # same as sigset[signum] = false
IPC.sigismember(sigset, signum)  # same as sigset[signum]
</code></pre><p><code>signum</code> is the signal number, an integer greater or equal <code>1</code> and less or equal<code>IPC.SIGRTMAX</code>.  Real-time signals have a number <code>signum</code> such that <code>IPC.SIGRTMIN ≤ signum ≤ IPC.SIGRTMAX</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L15-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.SigAction" href="#IPC.SigAction"><code>IPC.SigAction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SigAction</code> is the counterpart of the C <code>struct sigaction</code> structure.  It is used to specify the action taken by a process on receipt of a signal.  Assuming <code>sa</code> is an instance of <code>SigAction</code>, its fields are:</p><pre><code class="language-julia">sa.handler         # address of a signal handler
sa.mask            # mask of the signals to block
sa.flags           # bitwise flags</code></pre><p>where <code>sa.handler</code> is the address of a C function (can be <code>SIG_IGN</code> or <code>SIG_DFL</code>) to be called on receipt of the signal.  This function may be given by <code>cfunction</code>.  If <code>IPC.SA_INFO</code> is not set in <code>sa.flags</code>, then the signature of the handler is:</p><p>``julia function handler(signum::Cint)::Nothing</p><pre><code class="language-none">
that is a function which takes a single argument of type `Cint` and returns
nothing; if `IPC.SA_INFO` is not set in `sa.flags`, then the signature of the
handler is:

``julia
function handler(signum::Cint, siginf::Ptr{SigInfo}, unused::Ptr{Cvoid})::Nothing</code></pre><p>that is a function which takes 3 arguments of type <code>Cint</code>, <code>Ptr{SigInfo}</code>, <code>Ptr{Cvoid}</code> repectively and which returns nothing.  See <a href="#IPC.SigInfo"><code>SigInfo</code></a> for a description of the <code>siginf</code> argument by the handler.</p><p>Call:</p><pre><code class="language-julia">sa = SigAction()</code></pre><p>to create a new empty structure or</p><pre><code class="language-julia">sa = SigAction(handler, mask, flags)</code></pre><p>to provide all fields.</p><p>See also <a href="#IPC.SigInfo"><code>SigInfo</code></a>, <a href="#IPC.sigaction"><code>sigaction</code></a> and <a href="#IPC.sigaction!"><code>sigaction!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L355-L405">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.SigInfo" href="#IPC.SigInfo"><code>IPC.SigInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>SigInfo</code> represents a C <code>siginfo_t</code> structure.  It should be considered as opaque, its contents is stored as a tuple of unsigned integers whose size matches that of <code>siginfo_t</code> but, in principle, only a pointer of it should be received by a signal handler established with the <code>SA_SIGINFO</code> flag.</p><p>Given <code>ptr</code>, an instance of <code>Ptr{SigInfo}</code> received by a signal handler, the members of the corresponding C <code>siginfo_t</code> structure are retrieved by:</p><pre><code class="language-julia">IPC.siginfo_signo(ptr)  # Signal number.
IPC.siginfo_code(ptr)   # Signal code.
IPC.siginfo_errno(ptr)  # If non-zero, an errno value associated with this
                        # signal.
IPC.siginfo_pid(ptr)    # Sending process ID.
IPC.siginfo_uid(ptr)    # Real user ID of sending process.
IPC.siginfo_addr(ptr)   # Address of faulting instruction.
IPC.siginfo_status(ptr) # Exit value or signal.
IPC.siginfo_band(ptr)   # Band event for SIGPOLL.
IPC.siginfo_value(ptr)  # Signal value.</code></pre><p>These methods are <em>unsafe</em> because they directly use an address.  They are therefore not exported by default.  Depending on the context, not all members of <code>siginfo_t</code> are relevant (furthermore they may be defined as union and thus overlap in memory).  For now, only the members defined by the POSIX standard are accessible.  Finally, the value given by <code>IPC.siginfo_value(ptr)</code> represents a C type <code>union sigval</code> (an union of a C <code>int</code> and a C <code>void*</code>), in Julia it is returned (and set in <a href="#IPC.sigqueue"><code>sigqueue</code></a>) as an integer large enough to represent both kind of values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L520-L552">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigaction" href="#IPC.sigaction"><code>IPC.sigaction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigaction(signum) -&gt; cur</code></pre><p>yields the current action taken by the process on receipt of the signal <code>signum</code>.</p><pre><code class="language-julia">sigaction(signum, sigact)</code></pre><p>installs <code>sigact</code> (an instance of <a href="#IPC.SigAction"><code>SigAction</code></a>) to be the action taken by the process on receipt of the signal <code>signum</code>.</p><p>Note that <code>signum</code> cannot be <code>SIGKILL</code> nor <code>SIGSTOP</code>.</p><p>See also <a href="#IPC.SigAction"><code>SigAction</code></a> and <a href="#IPC.sigaction!"><code>sigaction!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L416-L436">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigaction!" href="#IPC.sigaction!"><code>IPC.sigaction!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigaction!(signum, sigact, oldact) -&gt; oldact</code></pre><p>installs <code>sigact</code> to be the action taken by the process on receipt of the signal <code>signum</code>, overwrites <code>oldact</code> with the previous action and returns it. See <a href="#IPC.SigAction"><code>SigAction</code></a> and <a href="#IPC.sigaction"><code>sigaction</code></a> for more details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L453-L463">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigpending" href="#IPC.sigpending"><code>IPC.sigpending</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigpending() -&gt; mask</code></pre><p>yields the set of signals that are pending for delivery to the calling thread (i.e., the signals which have been raised while blocked).  The returned value is an instance of <a href="#IPC.SigSet"><code>SigSet</code></a>.</p><p>See also: <a href="#IPC.sigpending!"><code>sigpending!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L126-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigpending!" href="#IPC.sigpending!"><code>IPC.sigpending!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigpending!(mask) -&gt; mask</code></pre><p>overwites <code>mask</code> with the set of pending signals and returns its argument.</p><p>See also: <a href="#IPC.sigpending"><code>sigpending</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L141-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigprocmask" href="#IPC.sigprocmask"><code>IPC.sigprocmask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigprocmask() -&gt; cur</code></pre><p>yields the current set of blocked signals.  To change the set of blocked signals, call:</p><pre><code class="language-julia">sigprocmask(how, set)</code></pre><p>with <code>set</code> a <code>SigSet</code> mask and <code>how</code> a parameter which specifies how to interpret <code>set</code>:</p><ul><li><p><code>IPC.SIG_BLOCK</code>: The set of blocked signals is the union of the current set and the <code>set</code> argument.</p></li><li><p><code>IPC.SIG_UNBLOCK</code>: The signals in <code>set</code> are removed from the current set of blocked signals.  It is permissible to attempt to unblock a signal which is not blocked.</p></li><li><p><code>IPC.SIG_SETMASK</code>: The set of blocked signals is set to the argument <code>set</code>.</p></li></ul><p>See also: <a href="#IPC.sigprocmask!"><code>sigprocmask!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L160-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigprocmask!" href="#IPC.sigprocmask!"><code>IPC.sigprocmask!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><div><pre><code class="language-julia">sigprocmask() -&gt; cur</code></pre><p>yields the current set of blocked signals.  To change the set of blocked signals, call:</p><pre><code class="language-julia">sigprocmask(how, set)</code></pre><p>with <code>set</code> a <code>SigSet</code> mask and <code>how</code> a parameter which specifies how to interpret <code>set</code>:</p><ul><li><p><code>IPC.SIG_BLOCK</code>: The set of blocked signals is the union of the current set and the <code>set</code> argument.</p></li><li><p><code>IPC.SIG_UNBLOCK</code>: The signals in <code>set</code> are removed from the current set of blocked signals.  It is permissible to attempt to unblock a signal which is not blocked.</p></li><li><p><code>IPC.SIG_SETMASK</code>: The set of blocked signals is set to the argument <code>set</code>.</p></li></ul><p>See also: <a href="#IPC.sigprocmask!"><code>sigprocmask!</code></a>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigqueue" href="#IPC.sigqueue"><code>IPC.sigqueue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigqueue(pid, sig, val=0)</code></pre><p>sends the signal <code>sig</code> to the process whose identifier is <code>pid</code>.  Argument <code>val</code> is an optional value to join to to the signal.  This value represents a C type <code>union sigval</code> (an union of a C <code>int</code> and a C <code>void*</code>), in Julia it is specified as an integer large enough to represent both kind of values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L108-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigsuspend" href="#IPC.sigsuspend"><code>IPC.sigsuspend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigsuspend(mask)</code></pre><p>temporarily replaces the signal mask of the calling process with the mask given by <code>mask</code> and then suspends the process until delivery of a signal whose action is to invoke a signal handler or to terminate a process.</p><p>If the signal terminates the process, then <code>sigsuspend</code> does not return.  If the signal is caught, then <code>sigsuspend</code> returns after the signal handler returns, and the signal mask is restored to the state before the call to <code>sigsuspend</code>.</p><p>It is not possible to block <code>IPC.SIGKILL</code> or <code>IPC.SIGSTOP</code>; specifying these signals in mask, has no effect on the process&#39;s signal mask.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L234-L251">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigwait" href="#IPC.sigwait"><code>IPC.sigwait</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigwait(mask, timeout=Inf) -&gt; signum</code></pre><p>suspends execution of the calling thread until one of the signals specified in the signal set <code>mask</code> becomes pending.  The function accepts the signal (removes it from the pending list of signals), and returns the signal number <code>signum</code>.</p><p>Optional argument <code>timeout</code> can be specified to set a limit on the time to wait for one the signals to become pending.  <code>timeout</code> can be a real number to specify a number of seconds or an instance of <code>TimeSpec</code>.  If <code>timeout</code> is <code>Inf</code> (the default), it is assumed that there is no limit on the time to wait. If <code>timeout</code> is a number of seconds smaller or equal zero or if <code>timeout</code> is <code>TimeSpec(0,0)</code>, the methods performs a poll and returns immediately.  It none of the signals specified in the signal set <code>mask</code> becomes pending during the allowed waiting time, a <code>TimeoutError</code> exception is raised.</p><p>See also: <a href="#IPC.sigwait!"><code>sigwait!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L258-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.sigwait!" href="#IPC.sigwait!"><code>IPC.sigwait!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sigwait!(mask, info, timeout=Inf) -&gt; signum</code></pre><p>behaves like <a href="#IPC.sigwait"><code>sigwait</code></a> but additional argument <code>info</code> is an instance of <code>SigInfo</code> to store the information about the accepted signal, other arguments are as for the <a href="#IPC.sigwait"><code>sigwait</code></a> method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/signals.jl#L290-L300">source</a></section><h2><a class="nav-anchor" id="Wrapped-arrays-1" href="#Wrapped-arrays-1">Wrapped arrays</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.WrappedArray" href="#IPC.WrappedArray"><code>IPC.WrappedArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">WrappedArray(mem, [T [, dims...]]; offset=0)</code></pre><p>yields a Julia array whose elements are stored in the &quot;memory&quot; object <code>mem</code>. Argument <code>T</code> is the data type of the elements of the returned array and argument(s) <code>dims</code> specify the dimensions of the array.  If <code>dims</code> is omitted the result is a vector of maximal length (accounting for the offset and the size of the <code>mem</code> object).  If <code>T</code> is omitted, <code>UInt8</code> is assumed.</p><p>Keyword <code>offset</code> may be used to specify the address (in bytes) relative to <code>pointer(mem)</code> where is stored the first element of the array.</p><p>The size of the memory provided by <code>mem</code> must be sufficient to store all elements (accounting for the offset) and the alignment of the elements in memory must be a multiple of <code>Base.datatype_alignment(T)</code>.</p><p>Another possibility is:</p><pre><code class="language-julia">WrappedArray(mem, dec)</code></pre><p>where <code>mem</code> is the &quot;memory&quot; object and <code>dec</code> is a function in charge of decoding the array type and layout given the memory object.  The decoder is applied to the memory object as follow:</p><pre><code class="language-julia">dec(mem) -&gt; T, dims, offset</code></pre><p>which must yield the data type <code>T</code> of the array elements, the dimensions <code>dims</code> of the array and the offset of the first element relative to <code>pointer(mem)</code>.</p><p><strong>Restrictions</strong></p><p>The <code>mem</code> object must extend the methods <code>pointer(mem)</code> and <code>sizeof(mem)</code> which must respectively yield the base address of the memory provided by <code>mem</code> and the number of available bytes.  Furthermore, this memory is assumed to be available at least until object <code>mem</code> is reclaimed by the garbage collector.</p><p><strong>Shared Memory Arrays</strong></p><pre><code class="language-julia">WrappedArray(id, T, dims; perms=0o600, volatile=true)</code></pre><p>creates a new wrapped array whose elements (and a header) are stored in shared memory identified by <code>id</code> (see <a href="#IPC.SharedMemory"><code>SharedMemory</code></a> for a description of <code>id</code> and for keywords).  To retrieve this array in another process, just do:</p><pre><code class="language-julia">WrappedArray(id; readonly=false)</code></pre><p><strong>See Also</strong></p><p><a href="#IPC.SharedMemory"><code>SharedMemory</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/wrappedarrays.jl#L12-L75">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.TimeSpec" href="#IPC.TimeSpec"><code>IPC.TimeSpec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TimeSpec(sec, nsec)</code></pre><p>yields an instance of <code>TimeSpec</code> for an integer number of seconds <code>sec</code> and an integer number of nanoseconds <code>nsec</code> since the Epoch.</p><pre><code class="language-julia">TimeSpec(sec)</code></pre><p>yields an instance of <code>TimeSpec</code> for a, possibly fractional, number of seconds <code>sec</code> since the Epoch.  Argument can also be an instance of <a href="#IPC.TimeVal"><code>TimeVal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L205-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.TimeVal" href="#IPC.TimeVal"><code>IPC.TimeVal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TimeVal(sec, usec)</code></pre><p>yields an instance of <code>TimeVal</code> for an integer number of seconds <code>sec</code> and an integer number of microseconds <code>usec</code> since the Epoch.</p><pre><code class="language-julia">TimeVal(sec)</code></pre><p>yields an instance of <code>TimeVal</code> with a, possibly fractional, number of seconds <code>sec</code> since the Epoch.  Argument can also be an instance of <a href="#IPC.TimeSpec"><code>TimeSpec</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L226-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.clock_getres" href="#IPC.clock_getres"><code>IPC.clock_getres</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clock_getres(id) -&gt; ts</code></pre><p>yields the resolution (precision) of the specified clock <code>id</code>. The result is an instance of <code>IPC.TimeSpec</code>.  Clock identifier <code>id</code> can be <code>CLOCK_REALTIME</code> or <code>CLOCK_MONOTONIC</code> (described in <a href="#IPC.clock_gettime"><code>clock_gettime</code></a>).</p><p>See also <a href="#IPC.clock_gettime"><code>clock_gettime</code></a>, <a href="#IPC.clock_settime"><code>clock_settime</code></a>, <a href="#IPC.gettimeofday"><code>gettimeofday</code></a>, <a href="#IPC.nanosleep"><code>nanosleep</code></a>, <a href="#IPC.TimeSpec"><code>IPC.TimeSpec</code></a> and <a href="#IPC.TimeVal"><code>IPC.TimeVal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L107-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.clock_gettime" href="#IPC.clock_gettime"><code>IPC.clock_gettime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clock_gettime(id) -&gt; ts</code></pre><p>yields the time of the specified clock <code>id</code>.  The result is an instance of <code>IPC.TimeSpec</code>.  Clock identifier <code>id</code> can be one of:</p><ul><li><p><code>CLOCK_REALTIME</code>: System-wide clock that measures real (i.e., wall-clock) time.  This clock is affected by discontinuous jumps in the system time (e.g., if the system administrator manually changes the clock), and by the incremental adjustments performed by <code>adjtime</code> and NTP.</p></li><li><p><code>CLOCK_MONOTONIC</code>: Clock that cannot be set and represents monotonic time since some unspecified starting point.  This clock is not affected by discontinuous jumps in the system time.</p></li></ul><p>See also <a href="#IPC.clock_getres"><code>clock_getres</code></a>, <a href="#IPC.clock_settime"><code>clock_settime</code></a>, <a href="#IPC.gettimeofday"><code>gettimeofday</code></a>, <a href="#IPC.nanosleep"><code>nanosleep</code></a>, <a href="#IPC.TimeSpec"><code>IPC.TimeSpec</code></a> and <a href="#IPC.TimeVal"><code>IPC.TimeVal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L138-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.clock_settime" href="#IPC.clock_settime"><code>IPC.clock_settime</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clock_settime(id, ts)</code></pre><p>set the time of the specified clock <code>id</code> to <code>ts</code>.  Argument <code>ts</code> can be an instance of <code>IPC.TimeSpec</code> or a number of seconds.  Clock identifier <code>id</code> can be <code>CLOCK_REALTIME</code> or <code>CLOCK_MONOTONIC</code> (described in <a href="#IPC.clock_gettime"><code>clock_gettime</code></a>).</p><p>See also <a href="#IPC.clock_getres"><code>clock_getres</code></a>, <a href="#IPC.clock_gettime"><code>clock_gettime</code></a>, <a href="#IPC.gettimeofday"><code>gettimeofday</code></a>, <a href="#IPC.nanosleep"><code>nanosleep</code></a>, <a href="#IPC.TimeSpec"><code>IPC.TimeSpec</code></a> and <a href="#IPC.TimeVal"><code>IPC.TimeVal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L179-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.gettimeofday" href="#IPC.gettimeofday"><code>IPC.gettimeofday</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gettimeofday() -&gt; tv</code></pre><p>yields the current time as an instance of <code>IPC.TimeVal</code>.  The result can be converted into a fractional number of seconds by calling <code>float(tv)</code>.</p><p>See also: <a href="#IPC.TimeVal"><code>IPC.TimeVal</code></a>, <a href="#IPC.nanosleep"><code>nanosleep</code></a>, <a href="#IPC.clock_gettime"><code>clock_gettime</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L63-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.nanosleep" href="#IPC.nanosleep"><code>IPC.nanosleep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nanosleep(t) -&gt; rem</code></pre><p>sleeps for <code>t</code> seconds with nanosecond precision and returns the remaining time (in case of interrupts) as an instance of <code>IPC.TimeSpec</code>.  Argument can be a (fractional) number of seconds or an instance of <code>IPC.TimeSpec</code> or <code>IPC.TimeVal</code>.</p><p>The <code>sleep</code> method provided by Julia has only millisecond precision.</p><p>See also <a href="#IPC.gettimeofday"><code>gettimeofday</code></a>, <a href="#IPC.TimeSpec"><code>IPC.TimeSpec</code></a> and <a href="#IPC.TimeVal"><code>IPC.TimeVal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/utils.jl#L82-L98">source</a></section><h2><a class="nav-anchor" id="Exceptions-1" href="#Exceptions-1">Exceptions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IPC.TimeoutError" href="#IPC.TimeoutError"><code>IPC.TimeoutError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>TimeoutError</code> is used to throw a timeout exception.</p></div></div><a class="source-link" target="_blank" href="https://github.com/emmt/IPC.jl/blob/7c10ec051e4c817da0c97bb14a4b15a74578a463/src/types.jl#L12-L14">source</a></section><footer><hr/><a class="previous" href="../sharedmemory/"><span class="direction">Previous</span><span class="title">Shared Memory</span></a></footer></article></body></html>
